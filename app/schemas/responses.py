"""OpenAPI response schemas for consistent API documentation.

This module contains response models that follow the OpenAPI 3.0 specification
and RFC 9457 (Problem Details for HTTP APIs) for error responses.
"""

from typing import Any, Dict, List, Optional, Type, TypeVar, Union

from fastapi import status
from pydantic import BaseModel, Field, HttpUrl

# Type variable for generic response types
T = TypeVar("T")


class ErrorResponse(BaseModel):
    """Base error response model following RFC 9457."""

    type: HttpUrl = Field(
        default="about:blank",
        description="A URI reference that identifies the problem type.",
        example="https://example.com/probs/validation-error",
    )
    title: Optional[str] = Field(
        default=None,
        description="A short, human-readable summary of the problem type.",
        example="Validation Error",
    )
    status: int = Field(
        description="The HTTP status code generated by the origin server.",
        example=400,
    )
    detail: Optional[str] = Field(
        default=None,
        description="A human-readable explanation specific to this occurrence of the problem.",
        example="Your request contains invalid parameters",
    )
    instance: Optional[HttpUrl] = Field(
        default=None,
        description="A URI reference that identifies the specific occurrence of the problem.",
        example="/api/v1/resource/123",
    )
    correlation_id: Optional[str] = Field(
        default=None,
        description="A unique identifier for the request, used for error tracking.",
        example="550e8400-e29b-41d4-a716-446655440000",
    )

    class Config:
        schema_extra = {
            "example": {
                "type": "https://example.com/probs/validation-error",
                "title": "Validation Error",
                "status": 400,
                "detail": "Your request contains invalid parameters",
                "instance": "/api/v1/resource/123",
                "correlation_id": "550e8400-e29b-41d4-a716-446655440000",
            },
        }


class ValidationErrorDetail(BaseModel):
    """Detailed validation error information."""

    field: str = Field(description="The field that failed validation.", example="email")
    message: str = Field(
        description="A description of the validation error.",
        example="Invalid email format",
    )
    error_code: Optional[str] = Field(
        default=None,
        description="A machine-readable error code.",
        example="invalid_email",
    )


class ValidationErrorResponse(ErrorResponse):
    """Response model for validation errors (HTTP 422)."""

    errors: List[ValidationErrorDetail] = Field(
        description="Detailed validation error information.",
    )

    class Config:
        schema_extra = {
            "example": {
                "type": "https://example.com/probs/validation-error",
                "title": "Validation Error",
                "status": status.HTTP_422_UNPROCESSABLE_ENTITY,
                "detail": "Invalid request data",
                "instance": "/api/v1/resource/123",
                "correlation_id": "550e8400-e29b-41d4-a716-446655440000",
                "errors": [
                    {
                        "field": "email",
                        "message": "Invalid email format",
                        "error_code": "invalid_email",
                    },
                ],
            },
        }


# Standard error responses for OpenAPI documentation
RESPONSES: Dict[Union[int, str], Dict[str, Any]] = {
    status.HTTP_400_BAD_REQUEST: {
        "model": ErrorResponse,
        "description": "Bad Request - The request could not be understood or was missing required parameters.",
    },
    status.HTTP_401_UNAUTHORIZED: {
        "model": ErrorResponse,
        "description": "Unauthorized - Authentication failed or user doesn't have permissions.",
        "headers": {
            "WWW-Authenticate": {
                "description": "Indicates the authentication scheme and parameters to use",
                "schema": {"type": "string", "example": 'Bearer realm="api"'},
            },
        },
    },
    status.HTTP_403_FORBIDDEN: {
        "model": ErrorResponse,
        "description": "Forbidden - Access denied.",
    },
    status.HTTP_404_NOT_FOUND: {
        "model": ErrorResponse,
        "description": "Not Found - The requested resource was not found.",
    },
    status.HTTP_409_CONFLICT: {
        "model": ErrorResponse,
        "description": "Conflict - The request conflicts with the current state of the server.",
    },
    status.HTTP_422_UNPROCESSABLE_ENTITY: {
        "model": ValidationErrorResponse,
        "description": "Validation Error - The request was well-formed but was unable to be followed due to semantic errors.",
    },
    status.HTTP_429_TOO_MANY_REQUESTS: {
        "model": ErrorResponse,
        "description": "Too Many Requests - Rate limit exceeded.",
        "headers": {
            "Retry-After": {
                "description": "Indicates how long to wait before making a new request",
                "schema": {"type": "integer", "format": "int32", "example": 60},
            },
        },
    },
    status.HTTP_500_INTERNAL_SERVER_ERROR: {
        "model": ErrorResponse,
        "description": "Internal Server Error - An unexpected error occurred on the server.",
    },
    status.HTTP_503_SERVICE_UNAVAILABLE: {
        "model": ErrorResponse,
        "description": "Service Unavailable - The server is currently unable to handle the request due to temporary overloading or maintenance.",
        "headers": {
            "Retry-After": {
                "description": "Indicates how long to wait before making a new request",
                "schema": {"type": "integer", "format": "int32", "example": 60},
            },
        },
    },
}


def get_responses(
    *status_codes: int,
    model: Optional[Type[BaseModel]] = None,
    description: Optional[str] = None,
) -> Dict[Union[int, str], Dict[str, Any]]:
    """Get response models for OpenAPI documentation.

    Args:
        *status_codes: HTTP status codes to include in the response
        model: The response model for success cases (status 200/201)
        description: Custom description for the success response

    Returns:
        Dictionary of response models for OpenAPI documentation

    """
    responses = {}

    # Add success response if model is provided
    if model:
        success_code = status.HTTP_200_OK
        if any(sc in [201, 202, 204] for sc in status_codes):
            success_code = next(sc for sc in status_codes if sc in [201, 202, 204])

        success_desc = description or {
            200: "Successful Response",
            201: "Resource Created",
            202: "Request Accepted",
            204: "No Content",
        }.get(success_code, "Successful Response")

        responses[success_code] = {"model": model, "description": success_desc}

    # Add error responses
    for code in status_codes:
        if code in RESPONSES:
            responses[code] = RESPONSES[code]

    return responses
