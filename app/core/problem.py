"""Problem Details for HTTP APIs (RFC 9457) implementation."""

from __future__ import annotations

import builtins
import json
from enum import Enum
from http import HTTPStatus
from typing import Any, TypeVar

from fastapi import status
from pydantic import BaseModel, ConfigDict, Field

from app.core.utils.datetime_utils import format_utc_datetime

T = TypeVar("T", bound="Problem")


class ProblemType(str, Enum):
    """Standard problem types as defined by RFC 9457."""

    ABOUT_BLANK = "about:blank"
    VALIDATION_ERROR = "https://example.com/probs/validation-error"
    UNAUTHORIZED = "https://example.com/probs/unauthorized"
    FORBIDDEN = "https://example.com/probs/forbidden"
    NOT_FOUND = "https://example.com/probs/not-found"
    CONFLICT = "https://example.com/probs/conflict"
    TOO_MANY_REQUESTS = "https://example.com/probs/too-many-requests"
    INTERNAL_SERVER_ERROR = "https://example.com/probs/internal-server-error"
    SERVICE_UNAVAILABLE = "https://example.com/probs/service-unavailable"


PROBLEM_TYPE_MAP: dict[int, str] = {
    status.HTTP_400_BAD_REQUEST: ProblemType.VALIDATION_ERROR.value,
    status.HTTP_401_UNAUTHORIZED: ProblemType.UNAUTHORIZED.value,
    status.HTTP_403_FORBIDDEN: ProblemType.FORBIDDEN.value,
    status.HTTP_404_NOT_FOUND: ProblemType.NOT_FOUND.value,
    status.HTTP_409_CONFLICT: ProblemType.CONFLICT.value,
    status.HTTP_422_UNPROCESSABLE_CONTENT: ProblemType.VALIDATION_ERROR.value,
    status.HTTP_429_TOO_MANY_REQUESTS: ProblemType.TOO_MANY_REQUESTS.value,
    status.HTTP_500_INTERNAL_SERVER_ERROR: ProblemType.INTERNAL_SERVER_ERROR.value,
    status.HTTP_503_SERVICE_UNAVAILABLE: ProblemType.SERVICE_UNAVAILABLE.value,
}


class ErrorDetail(BaseModel):
    """Detailed error information for a specific field or context."""

    type: str
    message: str
    field: str | None = None
    value: Any = None
    code: str | None = None


class Problem(BaseModel):
    """RFC 9457 Problem Details for HTTP APIs.

    See: https://datatracker.ietf.org/doc/html/rfc9457
    """

    type: str = Field(
        default=ProblemType.ABOUT_BLANK,
        description="A URI reference [RFC3986] that identifies the problem type.",
    )
    title: str = Field(
        ...,
        description="A short, human-readable summary of the problem type.",
    )
    status: int | None = Field(
        None,
        description=(
            "The HTTP status code ([RFC9110], Section 15) generated by the origin server "
            "for this occurrence of the problem."
        ),
    )
    detail: str | None = Field(
        None,
        description="A human-readable explanation specific to this occurrence of the problem.",
    )
    instance: str | None = Field(
        None,
        description="A URI reference that identifies the specific occurrence of the problem.",
    )
    errors: list[ErrorDetail] = Field(
        default_factory=list,
        description="Additional error details for validation or business rule violations.",
    )
    timestamp: str = Field(
        default_factory=format_utc_datetime,
        description="When the error occurred, in ISO 8601 format with timezone info.",
    )
    trace_id: str | None = Field(
        None,
        description="A unique identifier for the request, used for correlation.",
        alias="traceId",
    )
    correlation_id: str | None = Field(
        default=None,
        description="Correlation identifier echoed back to clients.",
    )
    retry_after: int | None = Field(
        default=None,
        description="Number of seconds to wait before retrying the request.",
    )

    model_config = ConfigDict(
        populate_by_name=True,
        json_schema_extra={
            "example": {
                "type": "https://example.com/probs/validation-error",
                "title": "Your request parameters didn't validate.",
                "status": 400,
                "detail": "The request contains invalid parameters. See 'errors' for details.",
                "instance": "/products/123",
                "timestamp": "2023-10-15T12:00:00Z",
                "traceId": "abc123",
                "errors": [
                    {
                        "type": "validation",
                        "message": "Value must be at least 1",
                        "field": "quantity",
                        "value": 0,
                        "code": "min_value",
                    },
                ],
            },
        },
    )

    @classmethod
    def from_status(
        cls: builtins.type[T],
        status_code: int,
        detail: str | None = None,
        instance: str | None = None,
        errors: list[ErrorDetail] | None = None,
        trace_id: str | None = None,
        correlation_id: str | None = None,
        **kwargs: Any,
    ) -> T:
        """Create a Problem instance from an HTTP status code."""
        try:
            title = HTTPStatus(status_code).phrase
        except ValueError:
            title = "Unknown Error"
        problem_type = cls._get_problem_type(status_code)
        effective_trace_id = trace_id or correlation_id

        return cls(
            type=problem_type,
            title=title,
            status=status_code,
            detail=detail or title,
            instance=instance or "",
            errors=errors or [],
            trace_id=effective_trace_id,
            correlation_id=correlation_id,
            **kwargs,
        )

    @classmethod
    def from_exception(
        cls: builtins.type[T],
        exc: Exception,
        status_code: int = 500,
        instance: str | None = None,
        trace_id: str | None = None,
        correlation_id: str | None = None,
        **kwargs: Any,
    ) -> T:
        """Create a Problem instance from an exception."""
        return cls.from_status(
            status_code=status_code,
            detail=str(exc),
            instance=instance or "",
            trace_id=trace_id,
            correlation_id=correlation_id,
            **kwargs,
        )

    @classmethod
    def from_validation_errors(
        cls: builtins.type[T],
        errors: list[dict[str, Any]],
        instance: str | None = None,
        trace_id: str | None = None,
        correlation_id: str | None = None,
    ) -> T:
        """Create a Problem instance from Pydantic validation errors."""
        error_details = []

        for error in errors:
            loc = ".".join(str(item) for item in error["loc"] if item != "body")
            error_details.append(
                ErrorDetail(
                    type="validation",
                    message=error["msg"],
                    field=loc or None,
                    value=error.get("value"),
                    code=error.get("type"),
                ),
            )

        return cls.from_status(
            status_code=status.HTTP_422_UNPROCESSABLE_CONTENT,
            detail="Validation failed. See 'errors' for details.",
            instance=instance or "",
            errors=error_details,
            trace_id=trace_id,
            correlation_id=correlation_id,
        )

    @staticmethod
    def _get_problem_type(status_code: int) -> str:
        """Get the appropriate problem type URI for a status code."""
        # For now, default to about:blank; specific mappings can be added if needed
        return PROBLEM_TYPE_MAP.get(status_code, ProblemType.ABOUT_BLANK.value)

    def to_dict(self) -> dict[str, Any]:
        """Convert the Problem to a dictionary, excluding None values."""
        return self.model_dump(by_alias=True, exclude_none=True)

    def to_json(self, **kwargs: Any) -> str:
        """Serialize the Problem to a JSON string."""
        return json.dumps(self.to_dict(), **kwargs)

    @classmethod
    def from_dict(cls: builtins.type[T], data: dict[str, Any]) -> T:
        """Create a Problem from a dictionary."""
        return cls(**data)

    @classmethod
    def from_json(cls: builtins.type[T], json_str: str) -> T:
        """Create a Problem from a JSON string."""
        return cls.from_dict(json.loads(json_str))


# Common problem instances for standard HTTP errors
class Problems:
    """Factory for common problem instances."""

    @staticmethod
    def bad_request(
        detail: str | None = None,
        instance: str | None = None,
        errors: list[ErrorDetail] | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """400 Bad Request."""
        return Problem.from_status(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=detail
            or "The request could not be understood or was missing required parameters.",
            instance=instance,
            errors=errors,
            trace_id=trace_id,
        )

    @staticmethod
    def unauthorized(
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """401 Unauthorized."""
        return Problem.from_status(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=(
                detail
                or "Authentication failed or user doesn't have permissions for the "
                "requested operation."
            ),
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def forbidden(
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """403 Forbidden."""
        return Problem.from_status(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail or "You don't have permission to access this resource.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def not_found(
        resource: str | None = None,
        id: str | int | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """404 Not Found."""
        detail = "The requested resource was not found."
        if resource and id is not None:
            detail = f"{resource} with ID '{id}' not found."
        elif resource:
            detail = f"{resource} not found."

        return Problem.from_status(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail,
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def conflict(
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """409 Conflict."""
        return Problem.from_status(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
            or "A resource with this ID already exists or is in an inconsistent state.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def unprocessable_entity(
        detail: str | None = None,
        errors: list[ErrorDetail] | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """422 Unprocessable Entity."""
        return Problem.from_status(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=detail
            or "The request was well-formed but was unable to be followed due to semantic errors.",
            errors=errors or [],
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def too_many_requests(
        retry_after: int | None = None,
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """429 Too Many Requests."""
        problem = Problem.from_status(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=detail or "Too many requests, please try again later.",
            instance=instance,
            trace_id=trace_id,
        )

        if retry_after is not None:
            problem.retry_after = retry_after

        return problem

    @staticmethod
    def internal_server_error(
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """500 Internal Server Error."""
        return Problem.from_status(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail or "An unexpected error occurred on the server.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def service_unavailable(
        retry_after: int | None = None,
        detail: str | None = None,
        instance: str | None = None,
        trace_id: str | None = None,
    ) -> Problem:
        """503 Service Unavailable."""
        problem = Problem.from_status(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=detail
            or "The service is currently unavailable. Please try again later.",
            instance=instance,
            trace_id=trace_id,
        )

        if retry_after is not None:
            problem.retry_after = retry_after

        return problem
