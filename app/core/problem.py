"""Problem Details for HTTP APIs (RFC 9457) implementation."""

from __future__ import annotations

import json
from enum import Enum
from typing import Any, Dict, List, Optional, Type, TypeVar, Union

from app.core.utils.datetime_utils import format_utc_datetime

from fastapi import status
from pydantic import BaseModel, ConfigDict, Field
from http import HTTPStatus

T = TypeVar("T", bound="Problem")


class ProblemType(str, Enum):
    """Standard problem types as defined by RFC 9457."""

    ABOUT_BLANK = "about:blank"
    VALIDATION_ERROR = "https://example.com/probs/validation-error"
    UNAUTHORIZED = "https://example.com/probs/unauthorized"
    FORBIDDEN = "https://example.com/probs/forbidden"
    NOT_FOUND = "https://example.com/probs/not-found"
    CONFLICT = "https://example.com/probs/conflict"
    TOO_MANY_REQUESTS = "https://example.com/probs/too-many-requests"
    INTERNAL_SERVER_ERROR = "https://example.com/probs/internal-server-error"
    SERVICE_UNAVAILABLE = "https://example.com/probs/service-unavailable"


PROBLEM_TYPE_MAP: Dict[int, str] = {
    status.HTTP_400_BAD_REQUEST: ProblemType.VALIDATION_ERROR.value,
    status.HTTP_401_UNAUTHORIZED: ProblemType.UNAUTHORIZED.value,
    status.HTTP_403_FORBIDDEN: ProblemType.FORBIDDEN.value,
    status.HTTP_404_NOT_FOUND: ProblemType.NOT_FOUND.value,
    status.HTTP_409_CONFLICT: ProblemType.CONFLICT.value,
    status.HTTP_422_UNPROCESSABLE_CONTENT: ProblemType.VALIDATION_ERROR.value,
    status.HTTP_429_TOO_MANY_REQUESTS: ProblemType.TOO_MANY_REQUESTS.value,
    status.HTTP_500_INTERNAL_SERVER_ERROR: ProblemType.INTERNAL_SERVER_ERROR.value,
    status.HTTP_503_SERVICE_UNAVAILABLE: ProblemType.SERVICE_UNAVAILABLE.value,
}


class ErrorDetail(BaseModel):
    """Detailed error information for a specific field or context."""

    type: str
    message: str
    field: Optional[str] = None
    value: Any = None
    code: Optional[str] = None


class Problem(BaseModel):
    """RFC 9457 Problem Details for HTTP APIs.

    See: https://datatracker.ietf.org/doc/html/rfc9457
    """

    type: str = Field(
        default=ProblemType.ABOUT_BLANK,
        description="A URI reference [RFC3986] that identifies the problem type.",
    )
    title: str = Field(
        ...,
        description="A short, human-readable summary of the problem type.",
    )
    status: Optional[int] = Field(
        None,
        description="The HTTP status code ([RFC9110], Section 15) generated by the origin server for this occurrence of the problem.",
    )
    detail: Optional[str] = Field(
        None,
        description="A human-readable explanation specific to this occurrence of the problem.",
    )
    instance: Optional[str] = Field(
        None,
        description="A URI reference that identifies the specific occurrence of the problem.",
    )
    errors: List[ErrorDetail] = Field(
        default_factory=list,
        description="Additional error details for validation or business rule violations.",
    )
    timestamp: str = Field(
        default_factory=format_utc_datetime,
        description="When the error occurred, in ISO 8601 format with timezone info.",
    )
    trace_id: Optional[str] = Field(
        None,
        description="A unique identifier for the request, used for correlation.",
        alias="traceId",
    )
    correlation_id: Optional[str] = Field(
        default=None,
        description="Correlation identifier echoed back to clients.",
    )
    retry_after: Optional[int] = Field(
        default=None,
        description="Number of seconds to wait before retrying the request.",
    )

    model_config = ConfigDict(
        populate_by_name=True,
        json_schema_extra={
            "example": {
                "type": "https://example.com/probs/validation-error",
                "title": "Your request parameters didn't validate.",
                "status": 400,
                "detail": "The request contains invalid parameters. See 'errors' for details.",
                "instance": "/products/123",
                "timestamp": "2023-10-15T12:00:00Z",
                "traceId": "abc123",
                "errors": [
                    {
                        "type": "validation",
                        "message": "Value must be at least 1",
                        "field": "quantity",
                        "value": 0,
                        "code": "min_value",
                    },
                ],
            },
        },
    )

    @classmethod
    def from_status(
        cls: Type[T],
        status_code: int,
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        errors: Optional[List[ErrorDetail]] = None,
        trace_id: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any,
    ) -> T:
        """Create a Problem instance from an HTTP status code."""
        try:
            title = HTTPStatus(status_code).phrase
        except ValueError:
            title = "Unknown Error"
        problem_type = cls._get_problem_type(status_code)
        effective_trace_id = trace_id or correlation_id

        return cls(
            type=problem_type,
            title=title,
            status=status_code,
            detail=detail or title,
            instance=instance or "",
            errors=errors or [],
            trace_id=effective_trace_id,
            correlation_id=correlation_id,
            **kwargs,
        )

    @classmethod
    def from_exception(
        cls: Type[T],
        exc: Exception,
        status_code: int = 500,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any,
    ) -> T:
        """Create a Problem instance from an exception."""
        return cls.from_status(
            status_code=status_code,
            detail=str(exc),
            instance=instance or "",
            trace_id=trace_id,
            correlation_id=correlation_id,
            **kwargs,
        )

    @classmethod
    def from_validation_errors(
        cls: Type[T],
        errors: List[Dict[str, Any]],
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
        correlation_id: Optional[str] = None,
    ) -> T:
        """Create a Problem instance from Pydantic validation errors."""
        error_details = []

        for error in errors:
            loc = ".".join(str(item) for item in error["loc"] if item != "body")
            error_details.append(
                ErrorDetail(
                    type="validation",
                    message=error["msg"],
                    field=loc or None,
                    value=error.get("value"),
                    code=error.get("type"),
                ),
            )

        return cls.from_status(
            status_code=status.HTTP_422_UNPROCESSABLE_CONTENT,
            detail="Validation failed. See 'errors' for details.",
            instance=instance or "",
            errors=error_details,
            trace_id=trace_id,
            correlation_id=correlation_id,
        )

    @staticmethod
    def _get_problem_type(status_code: int) -> str:
        """Get the appropriate problem type URI for a status code."""
        # For now, default to about:blank; specific mappings can be added if needed
        return PROBLEM_TYPE_MAP.get(status_code, ProblemType.ABOUT_BLANK.value)

    def to_dict(self) -> Dict[str, Any]:
        """Convert the Problem to a dictionary, excluding None values."""
        return self.model_dump(by_alias=True, exclude_none=True)

    def to_json(self, **kwargs: Any) -> str:
        """Serialize the Problem to a JSON string."""
        return json.dumps(self.to_dict(), **kwargs)

    @classmethod
    def from_dict(cls: Type[T], data: Dict[str, Any]) -> T:
        """Create a Problem from a dictionary."""
        return cls(**data)

    @classmethod
    def from_json(cls: Type[T], json_str: str) -> T:
        """Create a Problem from a JSON string."""
        return cls.from_dict(json.loads(json_str))


# Common problem instances for standard HTTP errors
class Problems:
    """Factory for common problem instances."""

    @staticmethod
    def bad_request(
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        errors: Optional[List[ErrorDetail]] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """400 Bad Request."""
        return Problem.from_status(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=detail
            or "The request could not be understood or was missing required parameters.",
            instance=instance,
            errors=errors,
            trace_id=trace_id,
        )

    @staticmethod
    def unauthorized(
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """401 Unauthorized."""
        return Problem.from_status(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=detail
            or "Authentication failed or user doesn't have permissions for the requested operation.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def forbidden(
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """403 Forbidden."""
        return Problem.from_status(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=detail or "You don't have permission to access this resource.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def not_found(
        resource: Optional[str] = None,
        id: Optional[Union[str, int]] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """404 Not Found."""
        detail = "The requested resource was not found."
        if resource and id is not None:
            detail = f"{resource} with ID '{id}' not found."
        elif resource:
            detail = f"{resource} not found."

        return Problem.from_status(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=detail,
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def conflict(
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """409 Conflict."""
        return Problem.from_status(
            status_code=status.HTTP_409_CONFLICT,
            detail=detail
            or "A resource with this ID already exists or is in an inconsistent state.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def unprocessable_entity(
        detail: Optional[str] = None,
        errors: Optional[List[ErrorDetail]] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """422 Unprocessable Entity."""
        return Problem.from_status(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=detail
            or "The request was well-formed but was unable to be followed due to semantic errors.",
            errors=errors or [],
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def too_many_requests(
        retry_after: Optional[int] = None,
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """429 Too Many Requests."""
        problem = Problem.from_status(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=detail or "Too many requests, please try again later.",
            instance=instance,
            trace_id=trace_id,
        )

        if retry_after is not None:
            problem.retry_after = retry_after

        return problem

    @staticmethod
    def internal_server_error(
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """500 Internal Server Error."""
        return Problem.from_status(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=detail or "An unexpected error occurred on the server.",
            instance=instance,
            trace_id=trace_id,
        )

    @staticmethod
    def service_unavailable(
        retry_after: Optional[int] = None,
        detail: Optional[str] = None,
        instance: Optional[str] = None,
        trace_id: Optional[str] = None,
    ) -> Problem:
        """503 Service Unavailable."""
        problem = Problem.from_status(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=detail
            or "The service is currently unavailable. Please try again later.",
            instance=instance,
            trace_id=trace_id,
        )

        if retry_after is not None:
            problem.retry_after = retry_after

        return problem
